#ifndef INCLUDE_ECODAN_HEATPUMP_H
#define INCLUDE_ECODAN_HEATPUMP_H

#include "esphome/core/component.h"
#include "esphome/components/climate/climate.h"
#include "esphome/components/number/number.h"
#include "esphome/components/select/select.h"
#include "esphome/components/sensor/sensor.h"
#include "esphome/components/switch/switch.h"
#include "esphome/components/text_sensor/text_sensor.h"
#include "esphome/components/uart/uart.h"
#include "esphome/core/log.h"
#include "esphome/core/defines.h"
#include "commands.h"
#include "fields.h"
#include <cmath>
#include "parser.h"
#include <string>
#include <vector>
#define CONNECT_LEN 8
#define HEADER_LEN 8
#define RCVD_PKT_FAIL 0
#define RCVD_PKT_CONNECT_SUCCESS 1
#define READOUT_DELAY 100 // Delay between individual sensor reads
#define OPERATION_TIMEOUT_MS 300 // Timeout for command responses
#define MAX_BYTES_PER_LOOP 10 // Limit bytes processed per loop iteration
#define STATE_LOG_INTERVAL_MS 30000 // Log state every 30 seconds
#define MAX_INIT_RETRIES 10 // Maximum initialization attempts
#define INIT_RETRY_DELAY_MS 1000 // Delay between init retries
#define INIT_RETRY_INTERVAL_MS 2000 // Interval between initialization attempts

// Temperature limits for validation
#define MIN_TEMPERATURE 10.0f // Minimum temperature in °C
#define MAX_TEMPERATURE 30.0f // Maximum temperature in °C

namespace esphome {
namespace ecodan_ {

using namespace ecodan::fields;
using namespace ecodan::commands;
using namespace ecodan::parser;

using std::string;

const uint8_t CONNECT[CONNECT_LEN] = {0xfc, 0x5a, 0x02, 0x7a, 0x02, 0xca, 0x01, 0x5d};

// ECODAN_**_LIST generated by ESPHome and written in esphome/core/defines

#ifndef ECODAN_SENSOR_LIST
#define ECODAN_SENSOR_LIST(F, SEP)
#endif

#ifndef ECODAN_TEXT_SENSOR_LIST
#define ECODAN_TEXT_SENSOR_LIST(F, SEP)
#endif

#ifndef ECODAN_SWITCH_LIST
#define ECODAN_SWITCH_LIST(F, SEP)
#endif

#ifndef ECODAN_SELECT_LIST
#define ECODAN_SELECT_LIST(F, SEP)
#endif

#ifndef ECODAN_NUMBER_LIST
#define ECODAN_NUMBER_LIST(F, SEP)
#endif

#ifndef ECODAN_CLIMATE_LIST
#define ECODAN_CLIMATE_LIST(F, SEP)
#endif

#define ECODAN_DATA_SENSOR(s) s
#define COMMA ,

class EcodanHeatpump;
class EcodanSwitch : public switch_::Switch, public Component {
  public:
    void dump_config() override;
    void set_key(string key) {this->key_ = key;}
    void set_heatpump(EcodanHeatpump* heatpump) {this->heatpump_ = heatpump;}

  protected:
    void write_state(bool state) override;

    string key_;
    EcodanHeatpump* heatpump_;
};

class EcodanSelect: public select::Select, public Component {
  public:
    void dump_config() override;
    void set_key(string key) {this->key_ = key;}
    void set_heatpump(EcodanHeatpump* heatpump) {this->heatpump_ = heatpump;}

  protected:
    void control(const std::string &value) override;

    string key_;
    EcodanHeatpump* heatpump_;
};

class EcodanNumber: public number::Number, public Component {
  public:
    void dump_config() override;
    void set_key(string key) {this->key_ = key;}
    void set_heatpump(EcodanHeatpump* heatpump) {this->heatpump_ = heatpump;}

  protected:
    void control(float value) override;

    string key_;
    EcodanHeatpump* heatpump_;
};

class EcodanClimate: public climate::Climate, public Component {
  public:
    void setup() override;
    void dump_config() override;
    void set_zone(uint8_t zone) { this->zone_ = zone; }
    void set_heatpump(EcodanHeatpump* heatpump) { this->heatpump_ = heatpump; }
    void set_temperature_range(float min_temp, float max_temp) {
      this->min_temperature_ = min_temp;
      this->max_temperature_ = max_temp;
    }
    void set_temperature_step(float step) { this->temperature_step_ = step; }
    
    // Called when current temperature is updated from sensor data
    void update_current_temperature(float temperature);
    
    // Called when target temperature is updated from heat pump data
    void update_target_temperature(float temperature);

  protected:
    void control(const climate::ClimateCall &call) override;
    climate::ClimateTraits traits() override;

    uint8_t zone_ = 1;
    float min_temperature_ = 10.0f;
    float max_temperature_ = 30.0f;
    float temperature_step_ = 0.5f;
    EcodanHeatpump* heatpump_ = nullptr;
};

class EcodanHeatpump : public PollingComponent, public uart::UARTDevice {
  public:

    EcodanHeatpump (uart::UARTComponent *parent);

    void setup() override;

    void loop() override;
    
    void update() override;

    void dump_config() override;

    void setRemoteTemperature(float value, uint8_t zone = 1);

    // Sensor setters
#define ECODAN_SET_SENSOR(s) \
    void set_##s(sensor::Sensor* sensor) { s_##s##_ = sensor; }
    ECODAN_SENSOR_LIST(ECODAN_SET_SENSOR, )

#define ECODAN_SET_TEXT_SENSOR(ts) \
    void set_##ts(text_sensor::TextSensor* text_sensor) { ts_##ts##_ = text_sensor; }
    ECODAN_TEXT_SENSOR_LIST(ECODAN_SET_TEXT_SENSOR, )

    // Switch setters
#define ECODAN_SET_SWITCH(sw) \
    void set_##sw(EcodanSwitch* ecodanSwitch) { sw_##sw##_ = ecodanSwitch; ecodanSwitch->set_heatpump(this); }
    ECODAN_SWITCH_LIST(ECODAN_SET_SWITCH, )

    // Select setters
#define ECODAN_SET_SELECT(sl) \
    void set_##sl(EcodanSelect* ecodanSelect) { sl_##sl##_ = ecodanSelect; ecodanSelect->set_heatpump(this); }
    ECODAN_SELECT_LIST(ECODAN_SET_SELECT, )

    // Number setters
#define ECODAN_SET_NUMBER(nb) \
    void set_##nb(EcodanNumber* ecodanNumber) { nb_##nb##_ = ecodanNumber; ecodanNumber->set_heatpump(this); }
    ECODAN_NUMBER_LIST(ECODAN_SET_NUMBER, )

    // Climate setters
  private:
    void set_climate_zone(EcodanClimate*& zone_member, EcodanClimate* ecodanClimate);
  public:
    void set_climate_zone1(EcodanClimate* ecodanClimate);
    void set_climate_zone2(EcodanClimate* ecodanClimate);

  private:
    float get_zone_room_temp_setpoint(EcodanClimate* climate_zone);
  public:
    // Public getter for Zone 1 setpoint
    float get_zone1_room_temp_setpoint();

    // Public getter for Zone 2 setpoint (used for Zone 2 climate control)  
    float get_zone2_room_temp_setpoint();

    void sendSerialPacket(uint8_t *sendBuffer);

  private:
    bool isInitialized = false;
    int currentState = 0;
    
    // State machine variables
    enum class ComponentState {
      INITIALIZING,
      CONNECTED,
      READING_ENTITIES,
      WAITING_FOR_RESPONSE,
      SENDING_OPERATION,
      WAITING_FOR_OPERATION_RESPONSE,
      IDLE
    };
    
    ComponentState state_ = ComponentState::INITIALIZING;
    uint32_t last_command_time_ = 0;
    uint32_t last_read_time_ = 0;
    uint32_t last_cycle_complete_time_ = 0;
    uint8_t current_entity_index_ = 0;
    uint8_t pending_address_ = 0;
    bool waiting_for_response_ = false;
    uint8_t init_retry_count_ = 0;
    
    // Packet reading state variables (converted from static to instance variables)
    uint8_t read_state_ = 0; // 0: looking for start, 1: reading header, 2: reading payload
    uint8_t bytes_read_ = 0;
    uint8_t expected_length_ = 0;
    
    // Command queue for all operations (both sensor reads and user commands)
    struct PendingOperation {
      uint8_t buffer[PACKET_BUFFER_SIZE];
      bool is_pending;
      uint32_t queued_time;
      bool is_user_command; // true for user commands (0x41), false for sensor reads (0x42)
      uint8_t expected_response_address; // for sensor reads only
    };
    
    PendingOperation pending_operation_;
    bool operation_in_progress_ = false;
    
    // Entity tracking
    struct EntityInfo {
      uint8_t address;
      bool is_configured;
      const char* type; // "s", "ts", "sw", "sl", "nb"
    };
    
    std::vector<EntityInfo> entity_list_;
    
    void initialize();

    void receiveSerialPacket();

    int readPacket(uint8_t *data);
    
    static uint8_t calculateCheckSum(uint8_t *data);

    void parsePacket(uint8_t *packet);
    
    // New state machine methods
    void buildEntityList();
    void processStateMachine();
    void handleInitializing();
    void handleReading();
    void handleSendingOperation();
    void handleWaitingForOperationResponse();
    bool isTimeToReadNext();
    void queueCommand(uint8_t *commandBuffer);
    void queueSensorRead(uint8_t *readBuffer, uint8_t address);
    void sendQueuedOperation();
    
    // Helper methods
    void encodeRemoteTemperature(uint8_t *buffer, float temperature);
    void encodeRemoteTemperatureZone2(uint8_t *buffer, float temperature);
    void buildSensorReadPacket(uint8_t *buffer, uint8_t address);
    void addEntityIfNotPresent(uint8_t address, const char* type, const std::string& description);

    // Sensor member pointers
#define ECODAN_DECLARE_SENSOR(s) sensor::Sensor* s_##s##_{nullptr};
    ECODAN_SENSOR_LIST(ECODAN_DECLARE_SENSOR, )

#define ECODAN_DECLARE_TEXT_SENSOR(ts) text_sensor::TextSensor* ts_##ts##_{nullptr};
    ECODAN_TEXT_SENSOR_LIST(ECODAN_DECLARE_TEXT_SENSOR, )

    // Switch member pointers
#define ECODAN_DECLARE_SWITCH(sw) EcodanSwitch* sw_##sw##_{nullptr};
    ECODAN_SWITCH_LIST(ECODAN_DECLARE_SWITCH, )

    // Select member pointers
#define ECODAN_DECLARE_SELECT(sl) EcodanSelect* sl_##sl##_{nullptr};
    ECODAN_SELECT_LIST(ECODAN_DECLARE_SELECT, )

    // Number member pointers
#define ECODAN_DECLARE_NUMBER(nb) EcodanNumber* nb_##nb##_{nullptr};
    ECODAN_NUMBER_LIST(ECODAN_DECLARE_NUMBER, )

    // Climate member pointers
    EcodanClimate* climate_zone1_{nullptr};
    EcodanClimate* climate_zone2_{nullptr};
};

} // namespace ecodan_
} // namespace esphome

#endif // INCLUDE_ECODAN_HEATPUMP_H