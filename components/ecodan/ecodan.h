#ifndef INCLUDE_ECODAN_HEATPUMP_H
#define INCLUDE_ECODAN_HEATPUMP_H

#include "esphome/core/component.h"
#include "esphome/components/number/number.h"
#include "esphome/components/select/select.h"
#include "esphome/components/sensor/sensor.h"
#include "esphome/components/switch/switch.h"
#include "esphome/components/text_sensor/text_sensor.h"
#include "esphome/components/uart/uart.h"
#include "esphome/core/log.h"
#include "esphome/core/defines.h"
#include "commands.h"
#include "fields.h"
#include "parser.h"
#include <string>
#include <vector>
#define CONNECT_LEN 8
#define HEADER_LEN 8
#define RCVD_PKT_FAIL 0
#define RCVD_PKT_CONNECT_SUCCESS 1
#define POLL_INTERVAL 1000 // 1 second - faster now that we're non-blocking
#define READOUT_DELAY 100 // 100 ms
#define MAX_ENTITIES_PER_CYCLE 3 // Process max 3 entities per update cycle

namespace esphome {
namespace ecodan_ {

using namespace ecodan::fields;
using namespace ecodan::commands;
using namespace ecodan::parser;

using std::string;

const uint8_t CONNECT[CONNECT_LEN] = {0xfc, 0x5a, 0x02, 0x7a, 0x02, 0xca, 0x01, 0x5d};

// ECODAN_**_LIST generated by ESPHome and written in esphome/core/defines

#ifndef ECODAN_SENSOR_LIST
#define ECODAN_SENSOR_LIST(F, SEP)
#endif

#ifndef ECODAN_TEXT_SENSOR_LIST
#define ECODAN_TEXT_SENSOR_LIST(F, SEP)
#endif

#ifndef ECODAN_SWITCH_LIST
#define ECODAN_SWITCH_LIST(F, SEP)
#endif

#ifndef ECODAN_SELECT_LIST
#define ECODAN_SELECT_LIST(F, SEP)
#endif

#ifndef ECODAN_NUMBER_LIST
#define ECODAN_NUMBER_LIST(F, SEP)
#endif

#define ECODAN_DATA_SENSOR(s) s
#define COMMA ,

class EcodanHeatpump;
class EcodanSwitch : public switch_::Switch, public Component {
  public:
    void dump_config() override;
    void set_key(string key) {this->key_ = key;}
    void set_heatpump(EcodanHeatpump* heatpump) {this->heatpump_ = heatpump;}

  protected:
    void write_state(bool state) override;

    string key_;
    EcodanHeatpump* heatpump_;
};

class EcodanSelect: public select::Select, public Component {
  public:
    void dump_config() override;
    void set_key(string key) {this->key_ = key;}
    void set_heatpump(EcodanHeatpump* heatpump) {this->heatpump_ = heatpump;}

  protected:
    void control(const std::string &value) override;

    string key_;
    EcodanHeatpump* heatpump_;
};

class EcodanNumber: public number::Number, public Component {
  public:
    void dump_config() override;
    void set_key(string key) {this->key_ = key;}
    void set_heatpump(EcodanHeatpump* heatpump) {this->heatpump_ = heatpump;}

  protected:
    void control(float value) override;

    string key_;
    EcodanHeatpump* heatpump_;
};

class EcodanHeatpump : public PollingComponent, public uart::UARTDevice {
  public:

    EcodanHeatpump (uart::UARTComponent *parent);

    void setup() override;

    void update() override;

    void dump_config() override;

    void setRemoteTemperature(float value);

    // Sensor setters
#define ECODAN_SET_SENSOR(s) \
    void set_##s(sensor::Sensor* sensor) { s_##s##_ = sensor; }
    ECODAN_SENSOR_LIST(ECODAN_SET_SENSOR, )

#define ECODAN_SET_TEXT_SENSOR(ts) \
    void set_##ts(text_sensor::TextSensor* text_sensor) { ts_##ts##_ = text_sensor; }
    ECODAN_TEXT_SENSOR_LIST(ECODAN_SET_TEXT_SENSOR, )

    // Switch setters
#define ECODAN_SET_SWITCH(sw) \
    void set_##sw(EcodanSwitch* ecodanSwitch) { sw_##sw##_ = ecodanSwitch; ecodanSwitch->set_heatpump(this); }
    ECODAN_SWITCH_LIST(ECODAN_SET_SWITCH, )

    // Select setters
#define ECODAN_SET_SELECT(sl) \
    void set_##sl(EcodanSelect* ecodanSelect) { sl_##sl##_ = ecodanSelect; ecodanSelect->set_heatpump(this); }
    ECODAN_SELECT_LIST(ECODAN_SET_SELECT, )

    // Number setters
#define ECODAN_SET_NUMBER(nb) \
    void set_##nb(EcodanNumber* ecodanNumber) { nb_##nb##_ = ecodanNumber; ecodanNumber->set_heatpump(this); }
    ECODAN_NUMBER_LIST(ECODAN_SET_NUMBER, )

    // Public getter for Zone 1 setpoint
    float get_zone1_room_temp_setpoint() {
        if (nb_zone1_room_temp_setpoint_ != nullptr) {
            return nb_zone1_room_temp_setpoint_->state;
        }
        return 10.0; // Default minimum temperature
    }

    void sendSerialPacket(uint8_t *sendBuffer);
    void sendImmediatePacket(uint8_t *sendBuffer);

  private:
    bool isInitialized = false;
    int currentState = 0;
    
    // State machine variables
    enum class ComponentState {
      INITIALIZING,
      CONNECTED,
      READING_ENTITIES,
      WAITING_FOR_RESPONSE,
      SENDING_OPERATION,
      WAITING_FOR_OPERATION_RESPONSE,
      IDLE
    };
    
    ComponentState state_ = ComponentState::INITIALIZING;
    uint32_t last_command_time_ = 0;
    uint32_t last_read_time_ = 0;
    uint8_t current_entity_index_ = 0;
    uint8_t pending_address_ = 0;
    bool waiting_for_response_ = false;
    uint8_t init_retry_count_ = 0;
    
    // Command queue for all operations (both sensor reads and user commands)
    struct PendingOperation {
      uint8_t buffer[PACKET_BUFFER_SIZE];
      bool is_pending;
      uint32_t queued_time;
      bool is_user_command; // true for user commands (0x41), false for sensor reads (0x42)
      uint8_t expected_response_address; // for sensor reads only
    };
    
    PendingOperation pending_operation_;
    bool operation_in_progress_ = false;
    
    // Entity tracking
    struct EntityInfo {
      uint8_t address;
      bool is_configured;
      const char* type; // "s", "ts", "sw", "sl", "nb"
    };
    
    std::vector<EntityInfo> entity_list_;
    
    void initialize();

    void receiveSerialPacket();

    int readPacket(uint8_t *data);
    
    static uint8_t calculateCheckSum(uint8_t *data);

    void parsePacket(uint8_t *packet);
    
    // New state machine methods
    void buildEntityList();
    void processStateMachine();
    void handleInitializing();
    void handleReading();
    void handleSendingOperation();
    void handleWaitingForOperationResponse();
    bool isTimeToReadNext();
    void queueCommand(uint8_t *commandBuffer);
    void queueSensorRead(uint8_t *readBuffer, uint8_t address);
    void sendQueuedOperation();

    // Sensor member pointers
#define ECODAN_DECLARE_SENSOR(s) sensor::Sensor* s_##s##_{nullptr};
    ECODAN_SENSOR_LIST(ECODAN_DECLARE_SENSOR, )

#define ECODAN_DECLARE_TEXT_SENSOR(ts) text_sensor::TextSensor* ts_##ts##_{nullptr};
    ECODAN_TEXT_SENSOR_LIST(ECODAN_DECLARE_TEXT_SENSOR, )

    // Switch member pointers
#define ECODAN_DECLARE_SWITCH(sw) EcodanSwitch* sw_##sw##_{nullptr};
    ECODAN_SWITCH_LIST(ECODAN_DECLARE_SWITCH, )

    // Select member pointers
#define ECODAN_DECLARE_SELECT(sl) EcodanSelect* sl_##sl##_{nullptr};
    ECODAN_SELECT_LIST(ECODAN_DECLARE_SELECT, )

    // Number member pointers
#define ECODAN_DECLARE_NUMBER(nb) EcodanNumber* nb_##nb##_{nullptr};
    ECODAN_NUMBER_LIST(ECODAN_DECLARE_NUMBER, )
};

} // namespace ecodan_
} // namespace esphome

#endif // INCLUDE_ECODAN_HEATPUMP_H